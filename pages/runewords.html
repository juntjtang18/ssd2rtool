<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSD2R Tool — Runewords Planner</title>
  <style>
    :root { --bg:#0b0d10; --card:#12161c; --text:#e7eef7; --muted:#9db0c6; --line:#223041; --accent:#7bdcff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 22px 16px 40px; }
    h1 { margin: 6px 0 8px; font-size: 22px; }
    .sub { color:var(--muted); margin: 0 0 16px; line-height: 1.55; white-space: pre-line; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 980px){ .grid { grid-template-columns: 1fr 1fr; } }
    .card { background:var(--card); border:1px solid var(--line); border-radius: 14px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 14px; color: var(--accent); font-weight: 800; letter-spacing: .2px; }
    .row { display:flex; gap:10px; align-items:center; margin: 10px 0; }
    label { flex: 1; color:var(--muted); font-size: 13px; }
    select, input { width: 260px; padding: 10px 10px; border-radius: 10px; border: 1px solid var(--line); background:#0f1318; color:var(--text); font-size: 14px; }
    .btn { width: 100%; padding: 12px 14px; border: 0; border-radius: 12px; background: var(--accent); color:#05202a; font-weight: 900; cursor:pointer; margin-top: 8px; }
    .hr { height:1px; background:var(--line); margin: 12px 0; border:0; }
    .tiny { color:var(--muted); font-size: 12px; line-height: 1.55; white-space: pre-line; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* Planner emphasis */
    .bigNumber { font-size: 44px; font-weight: 950; margin: 6px 0 2px; line-height: 1.0; }
    .bigUnit { font-size: 13px; color: var(--muted); font-weight: 800; margin-left: 6px; }
    .planBox { border: 1px solid var(--line); border-radius: 12px; padding: 12px; background:#0f1318; }
    .planGrid { display:grid; grid-template-columns: 1fr 110px 110px; gap: 8px 10px; align-items:center; }
    .planHdr { color: var(--muted); font-weight: 800; font-size: 12px; }
    .planBoss { color: var(--accent); font-weight: 950; font-size: 14px; }
    .planCell { font-size: 14px; }
    .right { text-align:right; }
    .stopLine { margin-top: 10px; font-size: 14px; font-weight: 850; }

    /* Trade list */
    .tradeGrid { display:grid; grid-template-columns: 1fr 160px; gap: 6px 12px; margin-top: 8px; }
    .tradeGrid div { padding: 2px 0; }
    .tradeKey { color: var(--accent); font-weight: 900; }

    table { width:100%; border-collapse: collapse; }
    td { padding: 6px 0; border-bottom: 1px solid #1c2735; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>SSD2R Tool — Runewords Planner</h1>
    <p class="sub">Pick a runeword + season phase → get a farming plan.</p>

    <div class="grid">
      <!-- Inputs -->
      <div class="card">
        <h2>Inputs</h2>

        <div class="row">
          <label>Season phase</label>
          <select id="phase">
            <option value="1">Phase 1</option>
            <option value="2">Phase 2</option>
            <option value="3">Phase 3</option>
          </select>
        </div>

        <div class="row">
          <label>Search</label>
          <input id="q" placeholder="e.g. infi / hoto / enigma" />
        </div>

        <div class="row">
          <label>Tag</label>
          <select id="tag">
            <option value="all">All</option>
          </select>
        </div>

        <div class="row">
          <label>Runeword</label>
          <select id="rw"></select>
        </div>

        <button class="btn" id="calc">Calculate</button>

        <p class="tiny">
          <a href="../index.html">← Back to home</a> &nbsp;|&nbsp;
          <a href="./model.html">Key Pipeline Model</a>
        </p>
      </div>

      <!-- Planner Output (NO cost here) -->
      <div class="card">
        <h2>Farming Plan</h2>

        <div class="tiny">Total time</div>
        <div class="bigNumber"><span id="totalHours">—</span><span class="bigUnit">Hours</span></div>

        <div class="planBox" style="margin-top:10px;">
          <div class="planGrid mono" id="planGrid">
            <!-- filled by JS -->
          </div>
          <div class="stopLine mono" id="targetKeys">—</div>
        </div>

        <div class="planBox" style="margin-top:12px;">
          <div class="tiny" style="font-weight:900; color:var(--muted); margin-bottom:6px;">Trade list (extras)</div>
          <div class="tradeGrid mono" id="tradeList">—</div>
        </div>
      </div>

      <!-- Rune breakdown (Cost lives here) -->
      <div class="card" style="grid-column: 1 / -1;">
        <h2>Rune breakdown</h2>
        <div class="tiny mono" id="baseLine">—</div>
        <div class="bigNumber" style="font-size:34px; margin-top:10px;">
          <span id="totalCost">—</span><span class="bigUnit">Ist (Total Cost)</span>
        </div>
        <table id="tbl" style="margin-top:10px;"></table>
      </div>
    </div>
  </div>

  <script type="module">
    import { loadPriceTable } from "../model/priceTable.js";
    import { breakdownRuneword } from "../model/runewordsPlanner.js";
    import { computeFromIst } from "../model/keysPipeline.js";

    const el = (id) => document.getElementById(id);
    const fmt = (x, d=2) => (Number.isFinite(x) ? x.toFixed(d) : "—");

    const els = {
      phase: el("phase"),
      q: el("q"),
      tag: el("tag"),
      rw: el("rw"),
      calc: el("calc"),

      totalHours: el("totalHours"),
      planGrid: el("planGrid"),
      targetKeys: el("targetKeys"),
      tradeList: el("tradeList"),

      baseLine: el("baseLine"),
      totalCost: el("totalCost"),
      tbl: el("tbl"),
    };

    // Fixed planner buffer (no UI option)
    const BUFFER = 1.10;

    let priceTable = null;
    let runewordsData = null;
    let modelDefaults = null;

    async function loadRunewords() {
      const res = await fetch("../config/runewords.json", { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load runewords.json: HTTP ${res.status}`);
      return await res.json();
    }

    async function loadModelDefaults() {
      const res = await fetch("../config/model-parameters.json", { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load model-parameters.json: HTTP ${res.status}`);
      const json = await res.json();
      return json.defaults;
    }

    function setPhaseDefault() {
      const saved = localStorage.getItem("seasonPhase");
      const def = saved || String(priceTable.defaultPhase || modelDefaults.seasonPhase || 2);
      els.phase.value = ["1","2","3"].includes(def) ? def : "2";
    }

    function populateTagOptions() {
      els.tag.innerHTML = "";
      const optAll = document.createElement("option");
      optAll.value = "all";
      optAll.textContent = "All";
      els.tag.appendChild(optAll);

      for (const t of (runewordsData.tags || [])) {
        const opt = document.createElement("option");
        opt.value = t;
        opt.textContent = t;
        els.tag.appendChild(opt);
      }
    }

    function renderRunewordOptions() {
      const query = (els.q.value || "").trim().toLowerCase();
      const tag = els.tag.value || "all";

      const list = (runewordsData.runewords || []).filter(r => {
        const tags = Array.isArray(r.tags) ? r.tags : [];
        if (tag !== "all" && !tags.includes(tag)) return false;
        if (!query) return true;
        const hay = `${r.name} ${r.id} ${tags.join(" ")}`.toLowerCase();
        return hay.includes(query);
      });

      const prev = els.rw.value;
      els.rw.innerHTML = "";

      for (const r of list) {
        const opt = document.createElement("option");
        opt.value = r.id;
        opt.textContent = r.name;
        els.rw.appendChild(opt);
      }

      const stillThere = Array.from(els.rw.options).some(o => o.value === prev);
      if (stillThere) els.rw.value = prev;

      if (!els.rw.options.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(no match)";
        els.rw.appendChild(opt);
      }
    }

    function getSelectedRuneword() {
      const id = els.rw.value;
      return (runewordsData.runewords || []).find(x => x.id === id);
    }

    function renderBreakdown(rw, phase) {
      const b = breakdownRuneword({ priceTable, phase, runes: rw.runes });

      els.baseLine.textContent =
        `Base: ${rw.base || "—"} | Tags: ${(rw.tags || []).join(", ") || "—"} | Notes: ${rw.notes || "—"}`;

      els.totalCost.textContent = fmt(b.totalIst, 2);

      els.tbl.innerHTML = "";

      for (const row of b.rows) {
        const tr = document.createElement("tr");
        const td1 = document.createElement("td");
        td1.className = "mono";
        td1.textContent = row.rune;

        const td2 = document.createElement("td");
        td2.className = "mono";
        td2.style.textAlign = "right";
        td2.textContent = fmt(row.priceIst, 4);

        tr.appendChild(td1);
        tr.appendChild(td2);
        els.tbl.appendChild(tr);
      }

      const tr = document.createElement("tr");
      const td1 = document.createElement("td");
      td1.textContent = "Total Cost";
      const td2 = document.createElement("td");
      td2.className = "mono";
      td2.style.textAlign = "right";
      td2.textContent = fmt(b.totalIst, 4);
      tr.appendChild(td1);
      tr.appendChild(td2);
      els.tbl.appendChild(tr);

      return b;
    }

    // ----- Batch helpers (no fractional Ist payouts) -----
    function piecesPerIstFromPrice(priceIst) {
      if (!Number.isFinite(priceIst) || priceIst <= 0) return Infinity;
      return Math.max(1, Math.ceil(1 / priceIst));
    }

    function computeBatchableExtras({ RcTotal }) {
      const extras = Array.isArray(modelDefaults.extras) ? modelDefaults.extras : [];
      const rows = [];

      let bankableIst = 0;

      for (const e of extras) {
        const name = e.name ?? e.id ?? "Extra";
        const priceIst = Number(e.priceIst ?? e.price ?? e.valueIst);
        const dpr = Number(e.dropPerRun ?? e.D ?? e.rate);

        if (!Number.isFinite(priceIst) || priceIst <= 0) continue;
        if (!Number.isFinite(dpr) || dpr <= 0) continue;

        const ppi = Number.isFinite(e.piecesPerIst) ? Number(e.piecesPerIst) : piecesPerIstFromPrice(priceIst);
        if (!Number.isFinite(ppi) || ppi <= 0) continue;

        // Use integer pieces for display & batching (conservative)
        const pieces = Math.floor(RcTotal * dpr);
        const batches = Math.floor(pieces / ppi); // each batch = 1 Ist
        const rem = pieces - batches * ppi;

        bankableIst += batches;

        rows.push({
          name,
          pieces,
          ppi,
          batches,
          rem,
          dpr,
          priceIst
        });
      }

      // sort by realized Ist desc
      rows.sort((a,b)=> b.batches - a.batches);

      return { rows, bankableIst };
    }

    function runsNeededForNextBatch({ RcTotal, row }) {
      // EV runs needed for this item to gain +1 more Ist batch
      // (we use expected pieces, not floored pieces, for planning)
      const ppi = row.ppi;
      const dpr = row.dpr;
      if (!Number.isFinite(ppi) || !Number.isFinite(dpr) || dpr <= 0) return Infinity;

      const expectedPieces = RcTotal * dpr;
      const currentBatches = Math.floor(expectedPieces / ppi);
      const nextThreshold = (currentBatches + 1) * ppi;

      const needPieces = nextThreshold - expectedPieces;
      if (!(needPieces > 0)) return Infinity;

      return needPieces / dpr;
    }

    function topUpCountessRunsToBankableTarget({ baseRc, keysetsTarget, costIst }) {
      // We bank keys as integer keysets => keysetsTarget Ist
      // We bank extras as integer Ist batches (no fractions)
      // Target bankable total: ceil(costIst)
      const targetBankable = Math.ceil(costIst);

      let RcTotal = baseRc;
      let iter = 0;

      while (iter < 200) {
        const { rows, bankableIst } = computeBatchableExtras({ RcTotal });
        const bankableTotal = keysetsTarget + bankableIst;

        if (bankableTotal >= targetBankable) {
          return { RcTotal, rows, bankableIst, targetBankable };
        }

        // choose the fastest next +1 Ist batch by extra runs
        let best = { addRuns: Infinity, row: null };

        for (const r of rows) {
          const addRunsEV = runsNeededForNextBatch({ RcTotal, row: r });
          if (addRunsEV < best.addRuns) best = { addRuns: addRunsEV, row: r };
        }

        if (!Number.isFinite(best.addRuns) || best.addRuns === Infinity) {
          return { RcTotal, rows, bankableIst, targetBankable };
        }

        // enforce integer runs (planner)
        const addRunsInt = Math.max(1, Math.ceil(best.addRuns));
        RcTotal += addRunsInt;
        iter++;
      }

      const { rows, bankableIst } = computeBatchableExtras({ RcTotal });
      return { RcTotal, rows, bankableIst, targetBankable };
    }

    function renderPlanGrid({ hC, hS, hN, Rc, Rs, Rn }) {
      els.planGrid.innerHTML = "";

      const add = (txt, cls="") => {
        const d = document.createElement("div");
        d.className = cls;
        d.textContent = txt;
        els.planGrid.appendChild(d);
      };

      add("", "planHdr");
      add("Hours", "planHdr right");
      add("Runs", "planHdr right");

      add("Hell Countess", "planBoss");
      add(fmt(hC, 2), "planCell right");
      add(String(Rc), "planCell right");

      add("Hell Summoner", "planBoss");
      add(fmt(hS, 2), "planCell right");
      add(String(Rs), "planCell right");

      add("Hell Nihlathak", "planBoss");
      add(fmt(hN, 2), "planCell right");
      add(String(Rn), "planCell right");
    }

    function renderTradeList({ rows }) {
      if (!rows || !rows.length) {
        els.tradeList.textContent = "—";
        return;
      }

      els.tradeList.innerHTML = "";

      let totalBankable = 0;

      for (const r of rows) {
        // show only meaningful lines
        if (r.batches <= 0 && r.pieces <= 0) continue;

        totalBankable += r.batches;

        const left = document.createElement("div");
        left.innerHTML =
          `<span class="tradeKey">${r.name}</span>  (${r.ppi}×${r.batches}${r.batches>0 ? "" : ""}` +
          `${r.pieces>0 ? `, rem ${r.rem}` : ""})`;

        const right = document.createElement("div");
        right.className = "right";
        right.textContent = `${r.batches} Ist`;

        els.tradeList.appendChild(left);
        els.tradeList.appendChild(right);
      }

      const l2 = document.createElement("div");
      l2.textContent = "Total extras (bankable)";
      const r2 = document.createElement("div");
      r2.className = "right";
      r2.textContent = `${totalBankable} Ist`;
      els.tradeList.appendChild(l2);
      els.tradeList.appendChild(r2);
    }

    function calc() {
      const phase = els.phase.value;
      localStorage.setItem("seasonPhase", phase);

      const rw = getSelectedRuneword();
      if (!rw) return;

      const b = renderBreakdown(rw, phase);
      const costIst = b.totalIst;

      // Base pipeline outputs (EV)
      const out = computeFromIst({
        Y: costIst,
        Dc: modelDefaults.Dc,
        Ds: modelDefaults.Ds,
        Dn: modelDefaults.Dn,
        tC_min: modelDefaults.tC_min,
        tS_min: modelDefaults.tS_min,
        tN_min: modelDefaults.tN_min,
        extras: modelDefaults.extras
      });

      // Key target (banked as integer keysets)
      const keysetsTarget = Math.ceil(out.X * BUFFER);

      // Base runs from pipeline, buffered & integer
      const baseRc = Math.ceil(out.Rc * BUFFER);
      const baseRs = Math.ceil(out.Rs * BUFFER);
      const baseRn = Math.ceil(out.Rn * BUFFER);

      // Top-up Countess runs so extras can be sold in integer Ist batches
      const topup = topUpCountessRunsToBankableTarget({
        baseRc,
        keysetsTarget,
        costIst
      });

      const RcPlan = topup.RcTotal;
      const RsPlan = baseRs;
      const RnPlan = baseRn;

      // Hours
      const hC = (RcPlan * modelDefaults.tC_min) / 60;
      const hS = (RsPlan * modelDefaults.tS_min) / 60;
      const hN = (RnPlan * modelDefaults.tN_min) / 60;
      const totalHoursPlan = hC + hS + hN;

      els.totalHours.textContent = fmt(totalHoursPlan, 2);

      renderPlanGrid({
        hC, hS, hN,
        Rc: RcPlan, Rs: RsPlan, Rn: RnPlan
      });

      els.targetKeys.textContent =
        `Stop at: ${keysetsTarget} TKey + ${keysetsTarget} HKey + ${keysetsTarget} DKey`;

      renderTradeList({ rows: topup.rows });
    }

    // init
    priceTable = await loadPriceTable();
    runewordsData = await loadRunewords();
    modelDefaults = await loadModelDefaults();

    populateTagOptions();
    setPhaseDefault();
    renderRunewordOptions();

    els.calc.addEventListener("click", calc);
    els.phase.addEventListener("change", calc);
    els.rw.addEventListener("change", calc);

    els.q.addEventListener("input", () => { renderRunewordOptions(); calc(); });
    els.tag.addEventListener("change", () => { renderRunewordOptions(); calc(); });

    calc();
  </script>
</body>
</html>
