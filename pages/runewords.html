<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSD2R Tool — Runewords Planner</title>
  <style>
    :root { --bg:#0b0d10; --card:#12161c; --text:#e7eef7; --muted:#9db0c6; --line:#223041; --accent:#7bdcff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 1040px; margin: 0 auto; padding: 22px 16px 40px; }
    h1 { margin: 6px 0 8px; font-size: 22px; }
    .sub { color:var(--muted); margin: 0 0 16px; line-height: 1.55; }

    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 980px){ .grid { grid-template-columns: 1fr 1fr; } }

    .card { background:var(--card); border:1px solid var(--line); border-radius: 14px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 14px; color: var(--accent); font-weight: 900; letter-spacing: .2px; }

    .row { display:flex; gap:10px; align-items:center; margin: 10px 0; }
    label { flex: 1; color:var(--muted); font-size: 13px; }
    select, input { width: 280px; padding: 10px 10px; border-radius: 10px; border: 1px solid var(--line); background:#0f1318; color:var(--text); font-size: 14px; }
    .btn { width: 100%; padding: 12px 14px; border: 0; border-radius: 12px; background: var(--accent); color:#05202a; font-weight: 900; cursor:pointer; margin-top: 8px; }

    .tiny { color:var(--muted); font-size: 12px; line-height: 1.55; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .bigNumber { font-size: 44px; font-weight: 950; margin: 6px 0 2px; line-height: 1.0; }
    .bigUnit { font-size: 13px; color: var(--muted); font-weight: 900; margin-left: 6px; }

    .box { border: 1px solid var(--line); border-radius: 12px; padding: 12px; background:#0f1318; }
    .divider { height:1px; background: var(--line); margin: 10px 0; }

    .planGrid { display:grid; grid-template-columns: 1fr 110px 110px; gap: 8px 10px; align-items:center; }
    .planHdr { color: var(--muted); font-weight: 900; font-size: 12px; }
    .planBoss { color: var(--accent); font-weight: 950; font-size: 14px; }
    .right { text-align:right; }
    .stopLine { margin-top: 10px; font-size: 14px; font-weight: 950; }

    .tradeGrid { display:grid; grid-template-columns: 1fr 160px; gap: 6px 12px; margin-top: 6px; }
    .tradeKey { color: var(--accent); font-weight: 950; }

    table { width:100%; border-collapse: collapse; }
    td { padding: 8px 0; border-bottom: 1px solid #1c2735; }
    .k { color: var(--accent); font-weight: 900; }
    .muted { color: var(--muted); }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>SSD2R Tool — Runewords Planner</h1>
    <div class="sub">Pick a runeword + season phase → get a farming plan.</div>

    <!-- Top row -->
    <div class="grid">
      <!-- Inputs -->
      <div class="card">
        <h2>Inputs</h2>

        <div class="row">
          <label>Season phase</label>
          <select id="phase">
            <option value="1">Phase 1</option>
            <option value="2">Phase 2</option>
            <option value="3">Phase 3</option>
          </select>
        </div>

        <div class="row">
          <label>Search</label>
          <input id="q" placeholder="e.g. infi / hoto / enigma" />
        </div>

        <div class="row">
          <label>Runeword</label>
          <select id="rw"></select>
        </div>

        <button class="btn" id="calc">Calculate</button>

        <div class="tiny" style="margin-top:10px;">
          <a href="../index.html">← Back</a> &nbsp;|&nbsp;
          <a href="./model.html">Key Pipeline</a>
        </div>
      </div>

      <!-- Planner -->
      <div class="card">
        <h2>Planner</h2>

        <div class="tiny">Total time</div>
        <div class="bigNumber"><span id="totalHours">—</span><span class="bigUnit">Hours</span></div>

        <div class="box" style="margin-top:10px;">
          <div class="planGrid mono" id="planGrid"></div>
          <div class="stopLine mono" id="targetLine">—</div>
        </div>

        <div class="box" style="margin-top:12px;">
          <div class="tiny muted" style="font-weight:900;">Trade list (extras)</div>
          <div class="tradeGrid mono" id="tradeList">—</div>
        </div>
      </div>
    </div>

    <!-- Bottom row -->
    <div class="grid" style="margin-top:14px;">
      <!-- Rune cost on LEFT -->
      <div class="card">
        <h2>Rune cost</h2>
        <div class="bigNumber" style="font-size:34px;">
          <span id="totalCost">—</span><span class="bigUnit">Ist</span>
        </div>
        <div class="divider"></div>
        <table class="mono" id="breakdownTable"></table>
      </div>

      <!-- Predicted drops on RIGHT -->
      <div class="card">
        <h2>Predicted drops</h2>
        <div class="box">
          <table class="mono" id="dropsTable"></table>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { loadPriceTable } from "../model/priceTable.js";
    import { breakdownRuneword } from "../model/runewordsPlanner.js";
    import { planRotationToTargetIst } from "../model/keysPipeline.js";

    const el = (id) => document.getElementById(id);

    // display-only buffer: ONLY applied to big total hours
    const DISPLAY_BUFFER = 1.10;

    // formatting rules for UX
    const fmtHours = (x) => (Number.isFinite(x) ? x.toFixed(1) : "—");     // 1 decimal
    const fmtIst1  = (x) => (Number.isFinite(x) ? x.toFixed(1) : "—");     // 1 decimal
    const asInt    = (x) => String(Math.max(0, Math.round(Number(x || 0)))); // integer count

    const els = {
      phase: el("phase"),
      q: el("q"),
      rw: el("rw"),
      calc: el("calc"),

      totalHours: el("totalHours"),
      planGrid: el("planGrid"),
      targetLine: el("targetLine"),
      tradeList: el("tradeList"),

      dropsTable: el("dropsTable"),
      totalCost: el("totalCost"),
      breakdownTable: el("breakdownTable"),
    };

    let priceTable = null;
    let runewordsData = null;
    let modelDefaults = null;

    async function loadRunewords() {
      const res = await fetch("../config/runewords.json", { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load runewords.json: HTTP ${res.status}`);
      return await res.json();
    }

    async function loadModelDefaults() {
      const res = await fetch("../config/model-parameters.json", { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load model-parameters.json: HTTP ${res.status}`);
      const json = await res.json();
      return json.defaults;
    }

    function setPhaseDefault() {
      const saved = localStorage.getItem("seasonPhase");
      const def = saved || String(priceTable.defaultPhase || modelDefaults.seasonPhase || 2);
      els.phase.value = ["1","2","3"].includes(def) ? def : "2";
    }

    function renderRunewordOptions() {
      const query = (els.q.value || "").trim().toLowerCase();
      const list = (runewordsData.runewords || []).filter(r => {
        if (!query) return true;
        const hay = `${r.name} ${r.id}`.toLowerCase();
        return hay.includes(query);
      });

      const prev = els.rw.value;
      els.rw.innerHTML = "";

      for (const r of list) {
        const opt = document.createElement("option");
        opt.value = r.id;
        opt.textContent = r.name;
        els.rw.appendChild(opt);
      }

      if (Array.from(els.rw.options).some(o => o.value === prev)) els.rw.value = prev;

      if (!els.rw.options.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(no match)";
        els.rw.appendChild(opt);
      }
    }

    function getSelectedRuneword() {
      const id = els.rw.value;
      return (runewordsData.runewords || []).find(x => x.id === id);
    }

    function renderRuneCost(rw, phase) {
      const b = breakdownRuneword({ priceTable, phase, runes: rw.runes });

      els.totalCost.textContent = fmtIst1(b.totalIst);

      els.breakdownTable.innerHTML = "";
      for (const row of b.rows) {
        const tr = document.createElement("tr");
        const td1 = document.createElement("td");
        td1.textContent = row.rune;

        const td2 = document.createElement("td");
        td2.style.textAlign = "right";
        td2.textContent = fmtIst1(row.priceIst);

        tr.appendChild(td1);
        tr.appendChild(td2);
        els.breakdownTable.appendChild(tr);
      }

      const tr = document.createElement("tr");
      const td1 = document.createElement("td");
      td1.textContent = "Total";
      const td2 = document.createElement("td");
      td2.style.textAlign = "right";
      td2.textContent = fmtIst1(b.totalIst);
      tr.appendChild(td1);
      tr.appendChild(td2);
      els.breakdownTable.appendChild(tr);

      return b;
    }

    function renderPlan(plan) {
      // buffer only the big number
      els.totalHours.textContent = fmtHours(plan.hours.total * DISPLAY_BUFFER);

      els.planGrid.innerHTML = "";
      const add = (txt, cls="") => {
        const d = document.createElement("div");
        d.className = cls;
        d.textContent = txt;
        els.planGrid.appendChild(d);
      };

      add("", "planHdr");
      add("Hours", "planHdr right");
      add("Runs", "planHdr right");

      add("Hell Countess", "planBoss");
      add(fmtHours(plan.hours.countess), "right");
      add(String(plan.runs.countess), "right");

      add("Hell Summoner", "planBoss");
      add(fmtHours(plan.hours.summoner), "right");
      add(String(plan.runs.summoner), "right");

      add("Hell Nihlathak", "planBoss");
      add(fmtHours(plan.hours.nihl), "right");
      add(String(plan.runs.nihl), "right");

      els.targetLine.textContent = `Stop at: ${plan.keys.keysets} keysets`;
    }

    function renderTradeList(plan) {
      const rows = Array.isArray(plan.tradeList) ? plan.tradeList : [];
      els.tradeList.innerHTML = "";

      if (!rows.length) {
        els.tradeList.textContent = "—";
        return;
      }

      for (const r of rows) {
        const left = document.createElement("div");
        left.innerHTML = `<span class="tradeKey">${r.name}</span>  (${r.O}×${r.orders})`;

        const right = document.createElement("div");
        right.style.textAlign = "right";
        right.textContent = `${Math.round(Number(r.ist || 0))} Ist`;

        els.tradeList.appendChild(left);
        els.tradeList.appendChild(right);
      }
    }

    // ✅ New: show all drops defined in drop table with dropRate >= 5% (regular extras),
    // regardless of price. Small drop rates are omitted.
    // Bonus stays as "Possible Bonus" (shown if pcs >= 1).
    function renderPredictedDrops(plan) {
      const extras = (plan.predictedDrops && Array.isArray(plan.predictedDrops.extras))
        ? plan.predictedDrops.extras
        : [];
      const bonus = (plan.predictedDrops && Array.isArray(plan.predictedDrops.bonus))
        ? plan.predictedDrops.bonus
        : [];

      const MIN_RATE = 0.05; // 5%
      const MIN_PCS = 1;

      const getRateFromDefaults = (name) => {
        const n = String(name || "").toUpperCase();
        const arr = Array.isArray(modelDefaults?.extras) ? modelDefaults.extras : [];
        const found = arr.find(x => String(x.name || x.id || "").toUpperCase().replace(/^BONUS\s*/i,"") === n);
        const dpr = Number(found?.dropPerRun ?? found?.D ?? found?.rate);
        return Number.isFinite(dpr) ? dpr : 0;
      };

      const rate = (x) => {
        const r = Number(x.dropRate);
        if (Number.isFinite(r) && r > 0) return r;
        return getRateFromDefaults(x.name);
      };

      const extrasShown = extras
        .map(x => ({ ...x, __r: rate(x) }))
        .filter(x => Number(x.pcs || 0) >= MIN_PCS)
        .filter(x => x.__r >= MIN_RATE)
        .sort((a,b) => b.__r - a.__r);

      const bonusShown = bonus
        .filter(x => Number(x.pcs || 0) >= MIN_PCS)
        .sort((a,b) => Number(b.pcs||0) - Number(a.pcs||0));

      els.dropsTable.innerHTML = "";

      const tr = (k, v, cls="") => {
        const row = document.createElement("tr");
        const td1 = document.createElement("td");
        td1.className = cls;
        td1.textContent = k;
        const td2 = document.createElement("td");
        td2.style.textAlign = "right";
        td2.textContent = v;
        row.appendChild(td1);
        row.appendChild(td2);
        return row;
      };

      // Always show keysets
      els.dropsTable.appendChild(tr("Keysets", String(plan.keys.keysets), "k"));

      // Regular extras (>=5% drop rate)
      for (const x of extrasShown) {
        els.dropsTable.appendChild(tr(x.name, asInt(x.pcs)));
      }

      // Bonus (Not guaranteed) — show only if pcs>=1
      if (bonusShown.length) {
        els.dropsTable.appendChild(tr("", ""));
        els.dropsTable.appendChild(tr("Possible Bonus (Not Guaranteed)", "", "muted"));
        for (const b of bonusShown) {
          els.dropsTable.appendChild(tr(b.name, asInt(b.pcs)));
        }
      }
    }

    function renderZeroState() {
      els.totalHours.textContent = fmtHours(0);

      els.planGrid.innerHTML = "";
      const add = (txt, cls="") => {
        const d = document.createElement("div");
        d.className = cls;
        d.textContent = txt;
        els.planGrid.appendChild(d);
      };

      add("", "planHdr");
      add("Hours", "planHdr right");
      add("Runs", "planHdr right");

      add("Hell Countess", "planBoss");
      add(fmtHours(0), "right");
      add("0", "right");

      add("Hell Summoner", "planBoss");
      add(fmtHours(0), "right");
      add("0", "right");

      add("Hell Nihlathak", "planBoss");
      add(fmtHours(0), "right");
      add("0", "right");

      els.targetLine.textContent = `Stop at: 0 keysets`;

      els.tradeList.textContent = "—";

      els.dropsTable.innerHTML = "";
      els.dropsTable.appendChild((() => {
        const row = document.createElement("tr");
        const td1 = document.createElement("td");
        td1.className = "k";
        td1.textContent = "Keysets";
        const td2 = document.createElement("td");
        td2.style.textAlign = "right";
        td2.textContent = "0";
        row.appendChild(td1);
        row.appendChild(td2);
        return row;
      })());
    }

    function calc() {
      const phase = els.phase.value;
      localStorage.setItem("seasonPhase", phase);

      const rw = getSelectedRuneword();
      if (!rw) return;

      const b = renderRuneCost(rw, phase);
      const costIst = Number(b.totalIst || 0);

      // cost=0 => show 0 plan
      if (!(costIst > 0)) {
        renderZeroState();
        return;
      }

      const plan = planRotationToTargetIst({
        targetIst: costIst,
        phase,
        priceTable,
        params: modelDefaults,
        buffer: 1.0
      });

      renderPlan(plan);
      renderTradeList(plan);
      renderPredictedDrops(plan);
    }

    // init
    priceTable = await loadPriceTable();
    runewordsData = await loadRunewords();
    modelDefaults = await loadModelDefaults();

    setPhaseDefault();
    renderRunewordOptions();

    els.calc.addEventListener("click", calc);
    els.phase.addEventListener("change", calc);
    els.rw.addEventListener("change", calc);
    els.q.addEventListener("input", () => { renderRunewordOptions(); calc(); });

    calc();
  </script>
</body>
</html>
