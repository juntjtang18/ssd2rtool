<!doctype html>
<!-- /pages/model.html -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>D2R Model (Theory EV)</title>
  <style>
    :root{
      --bg:#0b1220; --text:#e7eefc; --muted:#9db0d1;
      --accent:#65d2ff; --good:#8bffb1; --warn:#ffd38b; --bad:#ff8b8b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    body{ margin:0; background:linear-gradient(180deg,#070c16,var(--bg)); color:var(--text); font-family:var(--sans); }
    .wrap{ max-width:1100px; margin:24px auto; padding:0 16px; }
    h1{ font-size:20px; margin:0 0 14px; }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    @media (max-width: 900px){ .row{ grid-template-columns:1fr; } }
    .card{ background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.06); border-radius:14px; padding:16px; box-shadow:0 12px 26px rgba(0,0,0,0.35); }
    .card h2{ margin:0 0 10px; font-size:15px; color:var(--muted); }
    .sub{ color:var(--muted); font-size:12px; line-height:1.4; margin-top:6px; }
    label{ display:block; font-size:12px; color:var(--muted); margin:12px 0 6px; }
    input, select{ width:100%; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.22); color:var(--text); outline:none; }
    button{ width:100%; margin-top:12px; padding:12px 14px; border-radius:12px; border:0; cursor:pointer; font-weight:800; background:var(--accent); color:#05101f; }
    .mono{ font-family:var(--mono); }
    .kv{ display:flex; justify-content:space-between; gap:12px; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.06); }
    .kv:last-child{ border-bottom:0; }
    .k{ color:var(--muted); font-size:12px; }
    .v{ font-family:var(--mono); font-size:12px; white-space:nowrap; }
    .big{ font-size:38px; font-weight:900; letter-spacing:-0.02em; }
    .unit{ font-size:12px; color:var(--muted); margin-left:8px; font-weight:700; }
    .pillbar{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .pill{ display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.18); font-size:12px; color:var(--muted); }
    .pill strong{ color:var(--text); font-family:var(--mono); }
    .divider{ height:1px; background:rgba(255,255,255,0.06); margin:14px 0; }
    .note{ font-size:12px; color:var(--warn); margin-top:10px; }
    .err{ font-size:12px; color:var(--bad); white-space:pre-wrap; }
    .ok{ color:var(--good); }

    .topbar{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
    .langbox{ display:flex; align-items:center; gap:8px; margin-top: 2px; }
    .langbox .globe{ font-size: 16px; opacity:.9; }
    .langbox select{ width: 140px; padding: 9px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.22); color:var(--text); font-size: 14px; }
  
    .cap{ font-weight:900; color:var(--text); }
    .heroRow .k{ font-weight:900; color:var(--text); }
    .heroSmallNum{ font-size:26px; font-weight:900; letter-spacing:-0.01em; }
    .heroBigNum{ font-size:40px; font-weight:900; letter-spacing:-0.02em; }
    .heroUnit{ font-size:12px; color:var(--muted); margin-left:8px; font-weight:800; }
    .breakline{ margin-top:6px; font-size:13px; color:var(--text); font-weight:800; }
    .breakline .mut{ color:var(--muted); font-weight:800; }
    .itemsLine{ font-size:12px; color:var(--muted); font-family:var(--mono); line-height:1.5; }

</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 data-i18n="h1">D2R Keys Model (Theory EV) ‚Äî key-by-key rotation, extras only from Countess</h1>

      <div class="langbox" data-i18n-title="lang.title">
        <span class="globe">üåê</span>
        <select id="langSel" data-i18n-aria-label="lang.aria">
          <option value="zh-Hant" data-i18n="lang.zhHant">ÁπÅÈ´î</option>
          <option value="zh-Hans" data-i18n="lang.zhHans">ÁÆÄ‰Ωì</option>
          <option value="en" data-i18n="lang.en">EN</option>
        </select>
      </div>
    </div>

    <div class="card" style="margin-bottom:16px">
      <div class="row" style="grid-template-columns:1fr 1fr">
        <div>
          <label data-i18n="pricePhase">Price phase</label>
          <select id="phaseSel"></select>
          <div class="sub">/config/rune-price-table.json</div>
        </div>
        <div>
          <label data-i18n="modelParams">Model parameters</label>
          <div class="sub">/config/model-parameters.json</div>
          <div class="pillbar" id="quickStats"></div>
        </div>
      </div>
      <div class="sub" data-i18n-html="keyValueNote">
        Key value: 1 key = 1/3 Ist. Bonus is shown separately (EV only).
      </div>
      <div class="err" id="loadErr" style="display:none"></div>
    </div>

    <div class="row">
      <div class="card">
        <h2 data-i18n="sec1.title">1) Target Ist ‚Üí required hours + EV drops</h2>
        <label data-i18n="sec1.targetIst">Target Ist (exclude bonus)</label>
        <input id="targetIst" type="number" min="0" step="0.1" value="45" />
        <button id="btnTarget" data-i18n="btn.calculate">Calculate</button>
        <div class="divider"></div>
        <div id="outTarget"></div>
      </div>

      <div class="card">
        <h2 data-i18n="sec2.title">2) Target hours ‚Üí predicted Ist/h</h2>
        <label data-i18n="sec2.hours">Hours</label>
        <input id="hours" type="number" min="0" step="0.1" value="10" />
        <button id="btnHours" data-i18n="btn.calculate">Calculate</button>
        <div class="divider"></div>
        <div id="outHours"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { loadModelConfigs, getPhaseOptions, computeTheoryFromHours, computeTheoryFromTargetIst, priceInIst } from "../model/modelCore.js";
    import { computeMapEvModel, deriveRunTcCounts } from "../model/mapEvCore.js";
    import { detectLang, loadI18nJson, makeT, applyI18nToDom } from "../model/i18n.js";

    const el = (id) => document.getElementById(id);
    const fmt = (x, d=2) => (x == null || Number.isNaN(Number(x))) ? "-" : Number(x).toFixed(d);

    // i18n
    let dict = null;
    let t = (key, vars=null) => key;

    function applyLang(lang, { rerender = true } = {}) {
      localStorage.setItem("lang", lang);
      t = makeT(dict, lang);
      document.documentElement.lang = lang;
      document.title = t("title");
      applyI18nToDom(t);
      el("langSel").value = lang;
      if (rerender) {
        buildQuickStats();
        // keep outputs updated
        if (lastCalc?.kind === "target") renderTarget(lastCalc.result, lastCalc.input);
        if (lastCalc?.kind === "hours") renderFromHours(lastCalc.result, lastCalc.input);
      }
    }

    async function initI18n() {
      dict = await loadI18nJson("../i18n/model.json");
      const lang = detectLang();
      applyLang(lang, { rerender: false });
      el("langSel").addEventListener("change", () => applyLang(el("langSel").value));
    }

    let cfg = null;
    let phaseKey = null;
    let lastCalc = null;

    function currentPhaseData() {
      const phases = cfg?.priceTable?.phases ?? {};
      return phases?.[phaseKey] ?? {};
    }

    function getDefaults() {
      const d = cfg?.modelParameters?.defaults ?? {};
      return {
        Dc: Number(d.Dc),
        Ds: Number(d.Ds),
        Dn: Number(d.Dn),
        tC_min: Number(d.tC_min),
        tS_min: Number(d.tS_min),
        tN_min: Number(d.tN_min),
        extras: d.extras ?? [],
        tcDropTable: cfg?.tcDropTable ?? null,
        keyRuns: cfg?.keyRuns ?? null,
        predictableMinProb: 1/250
      };
    }

    
    function computeRotationDrops({ schedule }) {
      const { tcDropTable, keyRuns, predictableMinProb } = getDefaults();
      const phaseData = currentPhaseData();
      if (!tcDropTable || !keyRuns) return { regular: [], bonus: [], vexPlusProb: 0 };

      const bosses = [
        { id: "countess", runs: Number(schedule?.runs?.Rc ?? 0), runCfg: keyRuns.countess },
        { id: "summoner", runs: Number(schedule?.runs?.Rs ?? 0), runCfg: keyRuns.summoner },
        { id: "nihl", runs: Number(schedule?.runs?.Rn ?? 0), runCfg: keyRuns.nihl },
      ];

      const regMap = new Map();
      const bonMap = new Map();
      let vexPlusLambda = 0;

      for (const b of bosses) {
        if (!b.runCfg || !(b.runs > 0)) continue;
        const runTcCounts = deriveRunTcCounts({}, b.runCfg);
        const m = computeMapEvModel({ runTcCounts, tcDropTable, phaseData, predictableMinProb });

        for (const [item, perRun] of Object.entries(m?.predictable?.expectedDrops ?? {})) {
          const k = String(item ?? "").trim().toUpperCase();
          if (!k || ["UKEY","TKEY","HKEY","DKEY","KEYSET"].includes(k)) continue;
          regMap.set(k, (regMap.get(k) || 0) + Number(perRun) * b.runs);
        }
        for (const [item, perRun] of Object.entries(m?.lottery?.expectedDrops ?? {})) {
          const k = String(item ?? "").trim().toUpperCase();
          if (!k || ["UKEY","TKEY","HKEY","DKEY","KEYSET"].includes(k)) continue;
          bonMap.set(k, (bonMap.get(k) || 0) + Number(perRun) * b.runs);
        }

        vexPlusLambda += Number(m?.lottery?.vexPlusExpected ?? 0) * b.runs;
      }

      const vexPlusProb = vexPlusLambda > 0 ? (1 - Math.exp(-vexPlusLambda)) : 0;

      const toList = (m) => [...m.entries()]
        .filter(([,qty]) => qty > 0)
        .map(([name, qty]) => ({ name, qty }))
        .sort((a,b) => b.qty - a.qty);

      return { regular: toList(regMap), bonus: toList(bonMap), vexPlusProb };
    }

function buildQuickStats() {
      const { Dc, Ds, Dn, tC_min, tS_min, tN_min, extras, tcDropTable, keyRuns, predictableMinProb } = getDefaults();
      const pd = currentPhaseData();

      const timePerKeyC = (tC_min / Dc);
      const timePerKeyS = (tS_min / Ds);
      const timePerKeyN = (tN_min / Dn);
      const cycleMin = timePerKeyC + timePerKeyS + timePerKeyN;

      const extraNames = [...new Set((extras ?? []).map(x => String(x?.name ?? "").replace(/^BONUS\s*/i,"").trim()).filter(Boolean))];
      const picks = ["RAL","HEL","TAL","PG","PA","FG","FA","IST","UM","MAL", "PUL"].filter(x => (x in pd) || extraNames.includes(x));
      const priceStr = picks.map(n => `${n}=${fmt(priceInIst(n, pd),4)}`).join(" ¬∑ ");

      el("quickStats").innerHTML = [
        `<span class="pill">${t("stat.Dc")} <strong>${fmt(Dc,4)}</strong></span>`,
        `<span class="pill">${t("stat.Ds")} <strong>${fmt(Ds,4)}</strong></span>`,
        `<span class="pill">${t("stat.Dn")} <strong>${fmt(Dn,4)}</strong></span>`,
        `<span class="pill">${t("stat.tC")} <strong>${fmt(tC_min,2)}</strong> ${t("unit.min")}</span>`,
        `<span class="pill">${t("stat.tS")} <strong>${fmt(tS_min,2)}</strong> ${t("unit.min")}</span>`,
        `<span class="pill">${t("stat.tN")} <strong>${fmt(tN_min,2)}</strong> ${t("unit.min")}</span>`,
        `<span class="pill">${t("stat.cycle")} <strong>${fmt(cycleMin,2)}</strong> ${t("unit.min")}</span>`,
        `<span class="pill"><span class="mono">${priceStr || t("stat.pricesLoaded")}</span></span>`,
      ].join("");
    }

            function renderFromHours(r, hours) {
      const out = el("outHours");
      const s = r.schedule;
      const k = s.keys;

      const { extras, tC_min, tS_min, tN_min } = getDefaults();
      const Rc = s.runs.Rc;
      const Rs = s.runs.Rs;
      const Rn = s.runs.Rn;

      const cMin = Rc * tC_min;
      const sMin = Rs * tS_min;
      const nMin = Rn * tN_min;

      const { regular: regularDrops, bonus: bonusDrops, vexPlusProb } = computeRotationDrops({ schedule: s });

      const inlineList = (items) => {
        if (!items.length) return t("none");
        return items.map(it => `${it.name}: ${fmt(it.qty,2)}`).join(" ¬∑ ");
      };

      out.innerHTML = `
        <div class="kv heroRow">
          <div class="k cap">${t("out.farmingTime")}</div>
          <div class="v"><span class="heroSmallNum">${fmt(hours,2)}</span><span class="heroUnit">${t("unit.hour")}</span></div>
        </div>

        <div class="kv heroRow">
          <div class="k cap">${t("out.predictedRevenue")}</div>
          <div class="v"><span class="heroBigNum">${fmt(r.rates.istPerHourExclBonus,2)}</span><span class="heroUnit">${t("unit.istPerHour")}</span></div>
        </div>

        <div class="kv heroRow">
          <div class="k cap">${t("out.totalRevenue")}</div>
          <div class="v"><span class="heroSmallNum">${fmt(r.values.totalIstExclBonus,2)}</span><span class="heroUnit">${t("unit.ist")}</span></div>
        </div>

        <div class="breakline">
          ${t("out.key")}: ${fmt(r.values.keyIst,2)} ${t("unit.ist")}, ${t("out.extras")}: ${fmt(r.values.extrasRegularIst,2)} ${t("unit.ist")}
          <span class="mut">&nbsp;&nbsp;¬∑&nbsp;&nbsp;${t("out.bonusNotGuaranteed")}: ${fmt(r.values.bonusIst,2)} ${t("unit.ist")}</span>
        </div>

        <div class="divider"></div>

        <div class="sub cap">${t("out.farmingTimeByBoss")}</div>
        <div class="itemsLine">${t("boss.countess")}: ${fmt(cMin,2)} ${t("unit.min")} ¬∑ ${t("boss.summoner")}: ${fmt(sMin,2)} ${t("unit.min")} ¬∑ ${t("boss.nihla")}: ${fmt(nMin,2)} ${t("unit.min")}</div>

        <div class="divider"></div>

        <div class="sub cap">${t("out.drops")}</div>
        <div class="itemsLine">${fmt(k.terror,2)} TKey ¬∑ ${fmt(k.hate,2)} HKey ¬∑ ${fmt(k.destruction,2)} DKey</div>

        <div class="divider"></div>

        <div class="sub cap">Predicted Extra Drops</div>
        <div class="itemsLine">${inlineList(regularDrops)}</div>

        <div class="divider"></div>

        <div class="sub cap">Bonus Drops (Lottery, EV)</div>
        <div class="itemsLine">${(vexPlusProb>0?(`Vex+ ‚â•1: ${(vexPlusProb*100).toFixed(1)}% ¬∑ `):"")}${inlineList(bonusDrops)}</div>
      `;
    }

    
    function renderTarget(result, targetIst) {
      const out = el("outTarget");
      const r = result.result;
      const hours = result.required.hours;

      const s = r.schedule;
      const k = s.keys;

      const { extras, tC_min, tS_min, tN_min } = getDefaults();
      const Rc = s.runs.Rc;
      const Rs = s.runs.Rs;
      const Rn = s.runs.Rn;

      const cMin = Rc * tC_min;
      const sMin = Rs * tS_min;
      const nMin = Rn * tN_min;

      const { regular: regularDrops, bonus: bonusDrops, vexPlusProb } = computeRotationDrops({ schedule: s });

      const inlineList = (items) => {
        if (!items.length) return "(none)";
        return items.map(it => `${it.name}: ${fmt(it.qty,2)}`).join(" ¬∑ ");
      };

      out.innerHTML = `
        <div class="kv heroRow">
          <div class="k cap">Target Ist</div>
          <div class="v"><span class="heroSmallNum">${fmt(targetIst,2)}</span><span class="heroUnit">Ist</span></div>
        </div>

        <div class="kv heroRow">
          <div class="k cap">Required hours</div>
          <div class="v"><span class="heroSmallNum">${fmt(hours,2)}</span><span class="heroUnit">hour</span></div>
        </div>

        <div class="kv heroRow">
          <div class="k cap">Predicted Revenue</div>
          <div class="v"><span class="heroBigNum">${fmt(r.rates.istPerHourExclBonus,2)}</span><span class="heroUnit">Ist/hour</span></div>
        </div>

        <div class="kv heroRow">
          <div class="k cap">Total revenue</div>
          <div class="v"><span class="heroSmallNum">${fmt(r.values.totalIstExclBonus,2)}</span><span class="heroUnit">Ist</span></div>
        </div>

        <div class="breakline">
          Key: ${fmt(r.values.keyIst,2)} Ist, Extras: ${fmt(r.values.extrasRegularIst,2)} Ist
          <span class="mut">&nbsp;&nbsp;¬∑&nbsp;&nbsp;Bonus (Not guaranteed): ${fmt(r.values.bonusIst,2)} Ist</span>
        </div>

        <div class="divider"></div>

        <div class="sub cap">Farming time (by boss)</div>
        <div class="itemsLine">Countess: ${fmt(cMin,2)} min ¬∑ Summoner: ${fmt(sMin,2)} min ¬∑ Nihl: ${fmt(nMin,2)} min</div>

        <div class="divider"></div>

        <div class="sub cap">${t("out.drops")}</div>
        <div class="itemsLine">${fmt(k.terror,2)} TKey ¬∑ ${fmt(k.hate,2)} HKey ¬∑ ${fmt(k.destruction,2)} DKey</div>

        <div class="divider"></div>

        <div class="sub cap">Predicted Extra Drops</div>
        <div class="itemsLine">${inlineList(regularDrops)}</div>

        <div class="divider"></div>

        <div class="sub cap">Bonus Drops (Lottery, EV)</div>
        <div class="itemsLine">${(vexPlusProb>0?(`Vex+ ‚â•1: ${(vexPlusProb*100).toFixed(1)}% ¬∑ `):"")}${inlineList(bonusDrops)}</div>

        <div class="note">Target solving uses bisection over the same EV rotation model.</div>
      `;
    }


    async function main() {
      try {
        cfg = await loadModelConfigs();

        await initI18n();
        const { phases, defaultPhase } = getPhaseOptions(cfg.priceTable);
        phaseKey = defaultPhase;

        const sel = el("phaseSel");
        sel.innerHTML = Object.keys(phases)
          .sort((a,b)=>Number(a)-Number(b))
          .map(k => `<option value="${k}">${t("phase", { k })}</option>`)
          .join("");
        sel.value = phaseKey;
        sel.addEventListener("change", () => { phaseKey = sel.value; buildQuickStats(); if (lastCalc?.kind === "target") el("btnTarget").click(); if (lastCalc?.kind === "hours") el("btnHours").click(); });

        buildQuickStats();

        el("btnHours").addEventListener("click", () => {
          const hours = Number(el("hours").value);
          const { Dc, Ds, Dn, tC_min, tS_min, tN_min, extras, tcDropTable, keyRuns, predictableMinProb } = getDefaults();
          const r = computeTheoryFromHours({
            hours,
            Dc, Ds, Dn,
            tC_min, tS_min, tN_min,
            extras,
            phaseData: currentPhaseData(),
            tcDropTable,
            keyRuns,
            predictableMinProb
          });
          lastCalc = { kind: "hours", result: r, input: hours };
          renderFromHours(r, hours);
        });

        el("btnTarget").addEventListener("click", () => {
          const targetIst = Number(el("targetIst").value);
          const { Dc, Ds, Dn, tC_min, tS_min, tN_min, extras, tcDropTable, keyRuns, predictableMinProb } = getDefaults();
          const res = computeTheoryFromTargetIst({
            targetIst,
            Dc, Ds, Dn,
            tC_min, tS_min, tN_min,
            extras,
            phaseData: currentPhaseData(),
            tcDropTable,
            keyRuns,
            predictableMinProb
          });
          lastCalc = { kind: "target", result: res, input: targetIst };
          renderTarget(res, targetIst);
        });

        el("btnHours").click();
        el("btnTarget").click();

      } catch (e) {
        const errEl = el("loadErr");
        errEl.style.display = "block";
        errEl.textContent = `CONFIG LOAD ERROR\n\n${e?.message ?? e}`;
      }
    }

    main();
  </script>
</body>
</html>
