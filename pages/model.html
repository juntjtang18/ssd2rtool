<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSD2R Tool — Key Pipeline Model</title>
  <style>
    :root { --bg:#0b0d10; --card:#12161c; --text:#e7eef7; --muted:#9db0c6; --line:#223041; --accent:#7bdcff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 22px 16px 40px; }
    h1 { margin: 6px 0 8px; font-size: 22px; }
    .sub { color:var(--muted); margin: 0 0 16px; line-height: 1.55; white-space: pre-line; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 980px){ .grid { grid-template-columns: 1fr 1fr; } }
    .card { background:var(--card); border:1px solid var(--line); border-radius: 14px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 14px; color: var(--accent); font-weight: 700; }
    .row { display:flex; gap:10px; align-items:center; margin: 10px 0; }
    label { flex: 1; color:var(--muted); font-size: 13px; }
    input { width: 200px; padding: 10px 10px; border-radius: 10px; border: 1px solid var(--line); background:#0f1318; color:var(--text); font-size: 14px; }
    .btn { width: 100%; padding: 12px 14px; border: 0; border-radius: 12px; background: var(--accent); color:#05202a; font-weight: 900; cursor:pointer; margin-top: 8px; }
    .hr { height:1px; background:var(--line); margin: 12px 0; border:0; }
    .outBig { font-size: 34px; font-weight: 950; margin: 8px 0 4px; }
    .tiny { color:var(--muted); font-size: 12px; line-height: 1.55; white-space: pre-line; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    details { border: 1px solid var(--line); border-radius: 12px; padding: 10px 10px; background: #0f1318; }
    summary { cursor: pointer; color: var(--text); font-weight: 800; list-style: none; }
    summary::-webkit-details-marker { display:none; }
    .pill { display:inline-block; padding: 2px 8px; border:1px solid var(--line); border-radius: 999px; color: var(--muted); font-size: 12px; margin-left: 8px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .sectionTitle { margin: 14px 0 6px; font-weight: 900; color: var(--text); }
    .twoCol { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 980px){ .twoCol { grid-template-columns: 1fr 1fr; } }
    .warn { color: #ffd27d; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>SSD2R Tool — Key Pipeline Model</h1>
    <p class="sub">
Two calculators using the same centralized parameters:
(1) Target Ist → required hours + runs (C/S/N)  [closed-form model]
(2) Target hours → earned Ist + runs (C/S/N)   [discrete simulation, Policy A routing]

Notes:
- Inputs for Target Ist / Hours are integers (step=1).
- Hours input has minimum 3 (shorter sessions are too noisy).
- Simulation values are expected value (EV). Real results vary.
    </p>

    <!-- Shared Parameters -->
    <details open>
      <summary>
        Shared parameters (loaded from <span class="mono">/config/model-parameters.json</span>)
        <span class="pill" id="cfgStatus">loading…</span>
      </summary>

      <div style="margin-top:10px;" class="twoCol">
        <div class="card" style="margin:0;">
          <h2>Key drop rates (keys/run)</h2>
          <div class="row">
            <label>Dc (Countess)</label>
            <input id="Dc" type="number" step="0.0001" min="0.0001">
          </div>
          <div class="row">
            <label>Ds (Summoner)</label>
            <input id="Ds" type="number" step="0.0001" min="0.0001">
          </div>
          <div class="row">
            <label>Dn (Nihlathak)</label>
            <input id="Dn" type="number" step="0.0001" min="0.0001">
          </div>
          <p class="tiny">These are expected keys per run (drop probability).</p>
        </div>

        <div class="card" style="margin:0;">
          <h2>Run times (min/run)</h2>
          <div class="row">
            <label>tC (Countess)</label>
            <input id="tC_min" type="number" step="0.1" min="0.1">
          </div>
          <div class="row">
            <label>tS (Summoner)</label>
            <input id="tS_min" type="number" step="0.1" min="0.1">
          </div>
          <div class="row">
            <label>tN (Nihlathak)</label>
            <input id="tN_min" type="number" step="0.1" min="0.1">
          </div>
        </div>
      </div>

      <div class="tiny" id="extrasNote" style="margin-top:10px;"></div>
    </details>

    <div class="sectionTitle">1) Target Ist → required hours + runs</div>
    <div class="grid">
      <div class="card">
        <h2>Input</h2>

        <div class="row">
          <label>Target Ist (Y)</label>
          <input id="Y" type="number" step="1" min="1" value="45">
        </div>

        <button class="btn" id="calcIst">Calculate</button>

        <p class="tiny">
          <a href="../index.html">← Back to home</a>
        </p>
      </div>

      <div class="card">
        <h2>Output</h2>

        <div class="tiny">Required keysets (integer plan)</div>
        <div class="outBig"><span id="needKeysets">—</span> <span class="tiny">keysets</span></div>

        <div class="tiny">Required hours (for the integer plan)</div>
        <div class="outBig"><span id="needHours">—</span> <span class="tiny">hours</span></div>

        <hr class="hr"/>

        <div class="tiny mono" id="needRuns">Runs: —</div>
        <div class="tiny mono" id="needRevenue">—</div>
        <div class="tiny mono" id="needRate">—</div>

        <div class="tiny warn" id="needWarn"></div>
      </div>
    </div>

    <div class="sectionTitle">2) Target hours → earned Ist + runs (Simulation, Policy A)</div>
    <div class="grid">
      <div class="card">
        <h2>Input</h2>

        <div class="row">
          <label>Total hours (H)</label>
          <input id="H" type="number" step="1" min="3" value="20">
        </div>

        <button class="btn" id="calcHours">Simulate</button>

        <p class="tiny">
          Policy A routing: always farm the key type you have the least of; if tied, pick the most profitable node (usually Countess due to extras).
          Keys are valued as banked value (1 key = 1/3 Ist).
        </p>
      </div>

      <div class="card">
        <h2>Output</h2>

        <div class="tiny">Expected total value (banked)</div>
        <div class="outBig"><span id="earnIst">—</span> <span class="tiny">Ist</span></div>

        <hr class="hr"/>

        <div class="tiny mono" id="earnKeys">—</div>
        <div class="tiny mono" id="earnRuns">Runs: —</div>
        <div class="tiny mono" id="earnBreakdown">—</div>
        <div class="tiny mono" id="earnRate">—</div>

        <div class="tiny warn" id="earnWarn"></div>
      </div>
    </div>

  </div>

  <script type="module">
    import { computeFromIst } from "../model/keysPipeline.js";
    import { simulateBankedKeyValue } from "../model/keysPipelineSim.js";

    const el = (id) => document.getElementById(id);
    const fmt = (x, d=2) => (Number.isFinite(x) ? x.toFixed(d) : "—");
    const num = (inputEl) => {
      const n = parseFloat(inputEl.value);
      return Number.isFinite(n) ? n : NaN;
    };

    const els = {
      cfgStatus: el("cfgStatus"),
      extrasNote: el("extrasNote"),

      Dc: el("Dc"), Ds: el("Ds"), Dn: el("Dn"),
      tC_min: el("tC_min"), tS_min: el("tS_min"), tN_min: el("tN_min"),

      Y: el("Y"),
      H: el("H"),

      needKeysets: el("needKeysets"),
      needHours: el("needHours"),
      needRuns: el("needRuns"),
      needRevenue: el("needRevenue"),
      needRate: el("needRate"),
      needWarn: el("needWarn"),

      earnIst: el("earnIst"),
      earnKeys: el("earnKeys"),
      earnRuns: el("earnRuns"),
      earnBreakdown: el("earnBreakdown"),
      earnRate: el("earnRate"),
      earnWarn: el("earnWarn"),

      calcIst: el("calcIst"),
      calcHours: el("calcHours"),
    };

    let defaults = null;

    function splitExtras(extras) {
      const bonus = [];
      const regular = [];

      for (const e of (extras || [])) {
        const name = String(e.name || "");
        const priceIst = Number(e.priceIst) || 0;
        const dropPerRun = Number(e.dropPerRun) || 0;
        const item = { name, priceIst, dropPerRun };

        if (name.toLowerCase().startsWith("bonus")) bonus.push(item);
        else regular.push(item);
      }

      const VbonusC = bonus.reduce((s, e) => s + e.priceIst * e.dropPerRun, 0);
      const VregularC = regular.reduce((s, e) => s + e.priceIst * e.dropPerRun, 0);
      return { VbonusC, VregularC, bonus, regular };
    }

    function baseParams() {
      return {
        Dc: num(els.Dc),
        Ds: num(els.Ds),
        Dn: num(els.Dn),
        tC_min: num(els.tC_min),
        tS_min: num(els.tS_min),
        tN_min: num(els.tN_min),
        extras: (defaults && Array.isArray(defaults.extras)) ? defaults.extras : []
      };
    }

    async function loadDefaults() {
      try {
        const res = await fetch("../config/model-parameters.json", { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        defaults = json.defaults;

        els.Dc.value = defaults.Dc;
        els.Ds.value = defaults.Ds;
        els.Dn.value = defaults.Dn;

        els.tC_min.value = defaults.tC_min;
        els.tS_min.value = defaults.tS_min;
        els.tN_min.value = defaults.tN_min;

        const { VbonusC, VregularC } = splitExtras(defaults.extras);
        const VextraC = VbonusC + VregularC;

        els.extrasNote.textContent =
          `Extras (Countess-only) loaded: ${(defaults.extras||[]).length} items. ` +
          `VextraC ≈ ${fmt(VextraC, 4)} Ist/run(C) = regular ${fmt(VregularC,4)} + bonus ${fmt(VbonusC,4)}. ` +
          (VextraC <= 0 ? "⚠ Extras are OFF (dropPerRun=0)." : "Extras are ACTIVE.");

        els.cfgStatus.textContent = "loaded";
      } catch (e) {
        els.cfgStatus.textContent = "failed";
        console.error(e);
      }
    }

    function integerPlanFromKeysets(K, Dc, Ds, Dn, secPerKeyset, VregularC, VbonusC) {
      const Rc = K / Dc;
      const Rs = K / Ds;
      const Rn = K / Dn;

      const hours = (K * secPerKeyset) / 3600;

      const extraRegularIst = Rc * VregularC;
      const bonusExpectedIst = Rc * VbonusC;
      const keysetIst = K; // 1 keyset = 1 Ist

      const totalIst = keysetIst + extraRegularIst + bonusExpectedIst;
      const istPerHour = totalIst / hours;

      return { K, Rc, Rs, Rn, hours, keysetIst, extraRegularIst, bonusExpectedIst, totalIst, istPerHour };
    }

    function clampIntInput(inputEl, min) {
      const v = Math.floor(num(inputEl));
      const fixed = Number.isFinite(v) ? Math.max(min, v) : min;
      inputEl.value = String(fixed);
      return fixed;
    }

    function calcIst() {
      const Y = clampIntInput(els.Y, 1);
      const p = baseParams();
      const out = computeFromIst({ ...p, Y });

      const { VbonusC, VregularC } = splitExtras(p.extras);

      // integer keyset plan: CEIL so you reach the target with expectation
      const K = Math.max(1, Math.ceil(out.X));
      const plan = integerPlanFromKeysets(K, p.Dc, p.Ds, p.Dn, out.secPerKeyset, VregularC, VbonusC);

      els.needKeysets.textContent = String(plan.K);
      els.needHours.textContent = fmt(plan.hours, 2);

      els.needRuns.textContent =
        `Runs (expected): Rc=${fmt(plan.Rc, 0)} | Rs=${fmt(plan.Rs, 0)} | Rn=${fmt(plan.Rn, 0)}`;

      els.needRevenue.textContent =
        `Revenue: keysets=${fmt(plan.keysetIst,0)} Ist + extras=${fmt(plan.extraRegularIst,2)} Ist + bonus(EV)=${fmt(plan.bonusExpectedIst,2)} Ist = total ${fmt(plan.totalIst,2)} Ist`;

      els.needRate.textContent =
        `Predicted revenue/hour ≈ ${fmt(plan.istPerHour, 3)} Ist/h`;

      const margin = plan.totalIst - Y;
      els.needWarn.textContent =
        `Note: integer keysets means you may exceed target by ≈ ${fmt(margin,2)} Ist (expected).`;
    }

    function calcHours() {
      const H = clampIntInput(els.H, 3);
      const p = baseParams();

      // Simulation: Policy A routing inside the simulator
      const sim = simulateBankedKeyValue({
        hours: H,
        Dc: p.Dc, Ds: p.Ds, Dn: p.Dn,
        tC_min: p.tC_min, tS_min: p.tS_min, tN_min: p.tN_min,
        extras: p.extras,
        keyIst: 1 / 3,
        trials: 20000,
        seed: 12345
      });

      const a = sim.avg;

      els.earnIst.textContent = fmt(a.totalIst, 2);

      els.earnKeys.textContent =
        `Keys (EV): T≈${fmt(a.T, 2)} | H≈${fmt(a.H, 2)} | D≈${fmt(a.D, 2)}  (total≈${fmt(a.keys, 2)})`;

      els.earnRuns.textContent =
        `Runs (EV): Rc≈${fmt(a.runsC, 0)} | Rs≈${fmt(a.runsS, 0)} | Rn≈${fmt(a.runsN, 0)}`;

      els.earnBreakdown.textContent =
        `Value: banked keys≈${fmt(a.keyIst, 2)} Ist + extras≈${fmt(a.extrasIst, 2)} Ist  (VextraC≈${fmt(sim.VextraC, 4)} Ist/runC)`;

      els.earnRate.textContent =
        `Predicted revenue/hour ≈ ${fmt(a.istPerHour, 3)} Ist/h (EV over H=${H}h)`;

      els.earnWarn.textContent =
        `Note: EV only. Variance is high. Keys are valued as banked progress (1 key = 1/3 Ist).`;
    }

    await loadDefaults();

    // initial compute
    calcIst();
    calcHours();

    // buttons
    els.calcIst.addEventListener("click", calcIst);
    els.calcHours.addEventListener("click", calcHours);

    // auto-recalc on changes
    ["Dc","Ds","Dn","tC_min","tS_min","tN_min","Y","H"].forEach(id => {
      el(id).addEventListener("input", () => { calcIst(); calcHours(); });
    });
  </script>
</body>
</html>
