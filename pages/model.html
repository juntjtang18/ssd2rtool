<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSD2R Tool — Keyset Pipeline Model</title>
  <style>
    :root { --bg:#0b0d10; --card:#12161c; --text:#e7eef7; --muted:#9db0c6; --line:#223041; --accent:#7bdcff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 22px 16px 40px; }
    h1 { margin: 6px 0 8px; font-size: 22px; }
    .sub { color:var(--muted); margin: 0 0 16px; line-height: 1.55; white-space: pre-line; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 980px){ .grid { grid-template-columns: 1fr 1fr; } }
    .card { background:var(--card); border:1px solid var(--line); border-radius: 14px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 14px; color: var(--accent); font-weight: 700; }
    .row { display:flex; gap:10px; align-items:center; margin: 10px 0; }
    label { flex: 1; color:var(--muted); font-size: 13px; }
    input { width: 200px; padding: 10px 10px; border-radius: 10px; border: 1px solid var(--line); background:#0f1318; color:var(--text); font-size: 14px; }
    .btn { width: 100%; padding: 12px 14px; border: 0; border-radius: 12px; background: var(--accent); color:#05202a; font-weight: 900; cursor:pointer; margin-top: 8px; }
    .hr { height:1px; background:var(--line); margin: 12px 0; border:0; }
    .outBig { font-size: 34px; font-weight: 950; margin: 8px 0 4px; }
    .tiny { color:var(--muted); font-size: 12px; line-height: 1.55; white-space: pre-line; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    details { border: 1px solid var(--line); border-radius: 12px; padding: 10px 10px; background: #0f1318; }
    summary { cursor: pointer; color: var(--text); font-weight: 800; list-style: none; }
    summary::-webkit-details-marker { display:none; }
    .pill { display:inline-block; padding: 2px 8px; border:1px solid var(--line); border-radius: 999px; color: var(--muted); font-size: 12px; margin-left: 8px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .sectionTitle { margin: 14px 0 6px; font-weight: 900; color: var(--text); }
    .twoCol { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 980px){ .twoCol { grid-template-columns: 1fr 1fr; } }
    .warn { color: #ffd27d; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>SSD2R Tool — Keyset Pipeline Model</h1>
    <p class="sub">
Two calculators using the same centralized parameters:
(1) Target Ist → required hours + runs (C/S/N)
(2) Target hours → earned Ist + runs (C/S/N)

Keysets are displayed as INTEGERS:
- Target Ist: we CEIL keysets so you can actually reach the target.
- Target hours: we FLOOR keysets (conservative, no fractional keyset).
    </p>

    <!-- Shared Parameters -->
    <details open>
      <summary>
        Shared parameters (loaded from <span class="mono">/config/model-parameters.json</span>)
        <span class="pill" id="cfgStatus">loading…</span>
      </summary>

      <div style="margin-top:10px;" class="twoCol">
        <div class="card" style="margin:0;">
          <h2>Key drop rates (keys/run)</h2>
          <div class="row">
            <label>Dc (Countess)</label>
            <input id="Dc" type="number" step="0.0001" min="0.0001">
          </div>
          <div class="row">
            <label>Ds (Summoner)</label>
            <input id="Ds" type="number" step="0.0001" min="0.0001">
          </div>
          <div class="row">
            <label>Dn (Nihlathak)</label>
            <input id="Dn" type="number" step="0.0001" min="0.0001">
          </div>
          <p class="tiny">Runs are computed as: Rc=K/Dc, Rs=K/Ds, Rn=K/Dn (K = integer keysets).</p>
        </div>

        <div class="card" style="margin:0;">
          <h2>Run times (min/run)</h2>
          <div class="row">
            <label>tC (Countess)</label>
            <input id="tC_min" type="number" step="0.1" min="0.1">
          </div>
          <div class="row">
            <label>tS (Summoner)</label>
            <input id="tS_min" type="number" step="0.1" min="0.1">
          </div>
          <div class="row">
            <label>tN (Nihlathak)</label>
            <input id="tN_min" type="number" step="0.1" min="0.1">
          </div>
        </div>
      </div>

      <div class="tiny" id="extrasNote" style="margin-top:10px;"></div>
    </details>

    <div class="sectionTitle">1) Target Ist → required hours + runs</div>
    <div class="grid">
      <div class="card">
        <h2>Input</h2>

        <div class="row">
          <label>Target Ist (Y)</label>
          <input id="Y" type="number" step="1" min="1" value="45">
        </div>

        <button class="btn" id="calcIst">Calculate</button>

        <p class="tiny">
<a href="../index.html">← Back to home</a>
        </p>
      </div>

      <div class="card">
        <h2>Output</h2>

        <div class="tiny">Required keysets (integer, ceiled)</div>
        <div class="outBig"><span id="needKeysets">—</span> <span class="tiny">keysets</span></div>

        <div class="tiny">Required hours (for integer keysets)</div>
        <div class="outBig"><span id="needHours">—</span> <span class="tiny">hours</span></div>

        <hr class="hr"/>

        <div class="tiny mono" id="needRuns">Runs: —</div>
        <div class="tiny mono" id="needRevenue">—</div>
        <div class="tiny mono" id="needRate">—</div>

        <div class="tiny warn" id="needWarn"></div>
      </div>
    </div>

    <div class="sectionTitle">2) Target hours → earned Ist + runs</div>
    <div class="grid">
      <div class="card">
        <h2>Input</h2>

        <div class="row">
          <label>Total hours (H)</label>
          <input id="H" type="number" step="1" min="3" value="20">
        </div>

        <button class="btn" id="calcHours">Calculate</button>

        <p class="tiny">Note: we floor keysets (no fractional keyset). This is conservative.</p>
      </div>

      <div class="card">
        <h2>Output</h2>

        <div class="tiny">Completed keysets (integer, floored)</div>
        <div class="outBig"><span id="earnKeysets">—</span> <span class="tiny">keysets</span></div>

        <div class="tiny">Earned Ist (for integer keysets)</div>
        <div class="outBig"><span id="earnIst">—</span> <span class="tiny">Ist</span></div>

        <hr class="hr"/>

        <div class="tiny mono" id="earnRuns">Runs: —</div>
        <div class="tiny mono" id="earnRevenue">—</div>
        <div class="tiny mono" id="earnRate">—</div>

        <div class="tiny warn" id="earnWarn"></div>
      </div>
    </div>

  </div>

  <script type="module">
    import { computeFromIst, computeFromHours } from "../model/keysPipeline.js";

    const el = (id) => document.getElementById(id);
    const fmt = (x, d=2) => (Number.isFinite(x) ? x.toFixed(d) : "—");
    const num = (inputEl) => {
      const n = parseFloat(inputEl.value);
      return Number.isFinite(n) ? n : NaN;
    };

    const els = {
      cfgStatus: el("cfgStatus"),
      extrasNote: el("extrasNote"),

      Dc: el("Dc"), Ds: el("Ds"), Dn: el("Dn"),
      tC_min: el("tC_min"), tS_min: el("tS_min"), tN_min: el("tN_min"),

      Y: el("Y"),
      H: el("H"),

      needKeysets: el("needKeysets"),
      needHours: el("needHours"),
      needRuns: el("needRuns"),
      needRevenue: el("needRevenue"),
      needRate: el("needRate"),
      needWarn: el("needWarn"),

      earnKeysets: el("earnKeysets"),
      earnIst: el("earnIst"),
      earnRuns: el("earnRuns"),
      earnRevenue: el("earnRevenue"),
      earnRate: el("earnRate"),
      earnWarn: el("earnWarn"),

      calcIst: el("calcIst"),
      calcHours: el("calcHours"),
    };

    let defaults = null;

    function splitExtras(extras) {
      // Bonus detection rule: name starts with "Bonus"
      const bonus = [];
      const regular = [];

      for (const e of (extras || [])) {
        const name = String(e.name || "");
        const priceIst = Number(e.priceIst) || 0;
        const dropPerRun = Number(e.dropPerRun) || 0;
        const item = { name, priceIst, dropPerRun };

        if (name.toLowerCase().startsWith("bonus")) bonus.push(item);
        else regular.push(item);
      }

      const VbonusC = bonus.reduce((s, e) => s + e.priceIst * e.dropPerRun, 0);
      const VregularC = regular.reduce((s, e) => s + e.priceIst * e.dropPerRun, 0);
      return { VbonusC, VregularC, bonus, regular };
    }

    function baseParams() {
      return {
        Dc: num(els.Dc),
        Ds: num(els.Ds),
        Dn: num(els.Dn),
        tC_min: num(els.tC_min),
        tS_min: num(els.tS_min),
        tN_min: num(els.tN_min),
        extras: (defaults && Array.isArray(defaults.extras)) ? defaults.extras : []
      };
    }

    async function loadDefaults() {
      try {
        const res = await fetch("../config/model-parameters.json", { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        defaults = json.defaults;

        els.Dc.value = defaults.Dc;
        els.Ds.value = defaults.Ds;
        els.Dn.value = defaults.Dn;

        els.tC_min.value = defaults.tC_min;
        els.tS_min.value = defaults.tS_min;
        els.tN_min.value = defaults.tN_min;

        const { VbonusC, VregularC } = splitExtras(defaults.extras);
        const VextraC = VbonusC + VregularC;

        els.extrasNote.textContent =
          `Extras (Countess-only) loaded: ${(defaults.extras||[]).length} items. ` +
          `VextraC ≈ ${fmt(VextraC, 4)} Ist/run(C) = regular ${fmt(VregularC,4)} + bonus ${fmt(VbonusC,4)}. ` +
          (VextraC <= 0 ? "⚠ Extras are OFF (dropPerRun=0)." : "Extras are ACTIVE.");

        els.cfgStatus.textContent = "loaded";
      } catch (e) {
        els.cfgStatus.textContent = "failed";
        console.error(e);
      }
    }

    function integerPlanFromKeysets(K, Dc, Ds, Dn, secPerKeyset, VregularC, VbonusC) {
      // K is integer keysets
      const Rc = K / Dc;
      const Rs = K / Ds;
      const Rn = K / Dn;

      const hours = (K * secPerKeyset) / 3600;

      const extraRegularIst = Rc * VregularC;
      const bonusExpectedIst = Rc * VbonusC;
      const keyIst = K;
      const totalIst = keyIst + extraRegularIst + bonusExpectedIst;

      const istPerHour = totalIst / hours;

      return {
        K, Rc, Rs, Rn,
        hours,
        keyIst,
        extraRegularIst,
        bonusExpectedIst,
        totalIst,
        istPerHour
      };
    }

    function calcIst() {
      const Y = Math.floor(num(els.Y)); // enforce integer
      els.Y.value = String(Y);

      const p = baseParams();
      const out = computeFromIst({ ...p, Y }); // continuous model

      const { VbonusC, VregularC } = splitExtras(p.extras);

      // integer keysets: CEIL so target is achievable
      const K = Math.max(1, Math.ceil(out.X));
      const plan = integerPlanFromKeysets(K, p.Dc, p.Ds, p.Dn, out.secPerKeyset, VregularC, VbonusC);

      els.needKeysets.textContent = String(plan.K);
      els.needHours.textContent = fmt(plan.hours, 2);

      els.needRuns.textContent =
        `Runs (expected): Rc=${fmt(plan.Rc, 0)} | Rs=${fmt(plan.Rs, 0)} | Rn=${fmt(plan.Rn, 0)}`;

      els.needRevenue.textContent =
        `Revenue: keys=${fmt(plan.keyIst,0)} Ist + regular extras=${fmt(plan.extraRegularIst,2)} Ist + bonus(expected)=${fmt(plan.bonusExpectedIst,2)} Ist = total ${fmt(plan.totalIst,2)} Ist`;

      els.needRate.textContent =
        `Predicted revenue/hour ≈ ${fmt(plan.istPerHour, 3)} Ist/h`;

      const margin = plan.totalIst - Y;
      els.needWarn.textContent =
        `Note: integer keysets means you may exceed target by ≈ ${fmt(margin,2)} Ist (expected).`;
    }

    function calcHours() {
      const H = Math.floor(num(els.H)); // enforce integer
      els.H.value = String(H);

      const p = baseParams();
      const out = computeFromHours({ ...p, hours: H }); // continuous model

      const { VbonusC, VregularC } = splitExtras(p.extras);

      // integer keysets: FLOOR (conservative within given hours)
      const K = Math.max(0, Math.floor(out.X));

      if (K <= 0) {
        els.earnKeysets.textContent = "0";
        els.earnIst.textContent = "0.00";
        els.earnRuns.textContent = "Runs: Rc=0 | Rs=0 | Rn=0";
        els.earnRevenue.textContent = "Revenue: keys=0 Ist + regular extras=0 Ist + bonus(expected)=0 Ist";
        els.earnRate.textContent = `Predicted revenue/hour ≈ 0.000 Ist/h`;
        els.earnWarn.textContent = `Given H=${H} hours, predicted keysets < 1. Increase hours or reduce run times.`;
        return;
      }

      const plan = integerPlanFromKeysets(K, p.Dc, p.Ds, p.Dn, out.secPerKeyset, VregularC, VbonusC);

      // leftover time because we floored keysets
      const leftover = Math.max(0, H - plan.hours);

      els.earnKeysets.textContent = String(plan.K);
      els.earnIst.textContent = fmt(plan.totalIst, 2);

      els.earnRuns.textContent =
        `Runs (expected): Rc=${fmt(plan.Rc, 0)} | Rs=${fmt(plan.Rs, 0)} | Rn=${fmt(plan.Rn, 0)}`;

      els.earnRevenue.textContent =
        `Revenue: keys=${fmt(plan.keyIst,0)} Ist + regular extras=${fmt(plan.extraRegularIst,2)} Ist + bonus(expected)=${fmt(plan.bonusExpectedIst,2)} Ist = total ${fmt(plan.totalIst,2)} Ist`;

      // average over the whole input hours (not just used time)
      const avgOverH = plan.totalIst / H;
      els.earnRate.textContent =
        `Predicted revenue/hour ≈ ${fmt(avgOverH, 3)} Ist/h (over H=${H}h)`;

      els.earnWarn.textContent =
        `Flooring keysets leaves ≈ ${fmt(leftover,2)} hours unused in the integer plan (expected).`;
    }

    await loadDefaults();

    // initial compute
    calcIst();
    calcHours();

    // buttons
    els.calcIst.addEventListener("click", calcIst);
    els.calcHours.addEventListener("click", calcHours);

    // auto-recalc on any input changes
    ["Dc","Ds","Dn","tC_min","tS_min","tN_min","Y","H"].forEach(id => {
      el(id).addEventListener("input", () => { calcIst(); calcHours(); });
    });
  </script>
</body>
</html>
