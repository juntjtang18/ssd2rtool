<!doctype html>
<!-- /pages/rune-drops.html -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SSD2R Tool - Boss Rune Drop Rates</title>
  <style>
    :root{
      --bg:#0b1220; --text:#e7eefc; --muted:#9db0d1;
      --accent:#65d2ff; --good:#8bffb1; --warn:#ffd38b; --bad:#ff8b8b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    body{ margin:0; background:linear-gradient(180deg,#070c16,var(--bg)); color:var(--text); font-family:var(--sans); }
    .wrap{ max-width:1200px; margin:24px auto; padding:0 16px; }
    h1{ font-size:20px; margin:0 0 8px; }
    .sub{ color:var(--muted); font-size:12px; line-height:1.45; }
    .card{ background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.06); border-radius:14px; padding:16px; box-shadow:0 12px 26px rgba(0,0,0,0.35); }

    .controls{ display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; }
    .ctrl{ min-width:220px; }
    label{ display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    select{ width:100%; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.22); color:var(--text); outline:none; }
    .checkline{ display:flex; align-items:center; gap:8px; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.18); color:var(--muted); font-size:12px; }
    .checkline input{ width:16px; height:16px; }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    .tableWrap{ overflow:auto; border-radius:12px; border:1px solid rgba(255,255,255,0.06); }
    table{ width:max-content; min-width:100%; border-collapse:separate; border-spacing:0; }
    th, td{ padding:10px 12px; border-bottom:1px solid rgba(255,255,255,0.06); white-space:nowrap; }
    th{ text-align:left; font-size:12px; color:var(--muted); font-weight:900; position:sticky; top:0; background:rgba(7,12,22,0.92); backdrop-filter: blur(6px); z-index:3; }
    th.corner{ left:0; z-index:4; }
    td{ font-size:12px; }
    .mono{ font-family:var(--mono); }
    .num{ text-align:right; font-family:var(--mono); }

    td.sticky{ position:sticky; left:0; background:rgba(7,12,22,0.92); backdrop-filter: blur(6px); z-index:2; }
    tr:hover td{ color:var(--accent); }

    .runeBtn{ cursor:pointer; font-weight:900; }
    .runeBtn .hint{ font-weight:700; color:var(--muted); margin-left:8px; }

    .err{ font-size:12px; color:var(--bad); white-space:pre-wrap; }
    .pillbar{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .pill{ display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.18); font-size:12px; color:var(--muted); }
    .pill strong{ color:var(--text); font-family:var(--mono); }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Boss Rune Drop Rates</h1>
    <div class="sub">
      Table values are based on <span class="mono">expected drop count per kill</span> (not "chance of at least one").
      Click a rune name (left column) to sort bosses by that rune.
    </div>

    <div class="card" style="margin-top:14px; margin-bottom:16px;">
      <div class="controls">
        <div class="ctrl">
          <label>Display</label>
          <select id="fmtSel">
            <option value="perkill">Per kill (scientific)</option>
            <option value="onein">1:N (DropCalc style)</option>
            <option value="per10k">Per 10,000 kills</option>
            <option value="per1m">Per 1,000,000 kills</option>
          </select>
        </div>

        <div class="ctrl" style="min-width:180px;">
          <label>Precision</label>
          <select id="precSel">
            <option value="2">Compact</option>
            <option value="3" selected>Normal</option>
            <option value="5">Detailed</option>
          </select>
        </div>

        <div class="ctrl">
          <label>Rows</label>
          <div class="checkline">
            <input id="showAll" type="checkbox" />
            <span>Show all runes from price table (otherwise: high runes only)</span>
          </div>
        </div>

        <div class="ctrl" style="min-width:260px;">
          <label>Dataset</label>
          <div class="pillbar" id="metaPills"></div>
        </div>
      </div>

      <div class="err" id="loadErr" style="display:none; margin-top:10px;"></div>
      <div class="sub" style="margin-top:10px;">
        <a href="../index.html">&lt;- Back</a>
      </div>
    </div>

    <div class="card">
      <div class="tableWrap">
        <table>
          <thead id="thead"></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
      <div class="sub" style="margin-top:10px;">
        Tip: when a rune is selected for sorting, bosses are reordered left-to-right by that rune's drop rate.
      </div>
    </div>
  </div>

  <script type="module">
    import { loadPriceTable, normRune } from "../model/priceTable.js";
    import { BOSSES, loadBossDropsByFileId, formatBossMeta } from "../model/rpk.js";

    const el = (id) => document.getElementById(id);

    const EXCLUDE = new Set(["PG","PA","FG","FA","UKEY"]);
    // Default view: high runes only (always include ZOD even if not priced).
    const HIGH_RUNE_ROWS = ["PUL", "UM", "MAL", "IST", "GUL", "VEX","OHM","LO","SUR","BER","JAH","CHAM","ZOD"];
    // When showing all runes, we keep a reasonable ordering but also include anything else we see.
    const PREFERRED_ORDER = ["EL","ELD","TIR","NEF","ETH","ITH","TAL","RAL","ORT","THUL","AMN","SOL","SHAEL","DOL","HEL","IO","LUM","KO","FAL","LEM","PUL","UM","MAL","IST","GUL","VEX","OHM","LO","SUR","BER","JAH","CHAM","ZOD"];

    let priceTable = null;
    let bossesData = null; // [{id,label,data}, ...]

    let showAll = false;
    // Default to DropCalc-style readability.
    let fmtMode = "onein"; // onein | perk... | per10k | per1m
    let precision = 3; // 2 (compact), 3 (normal), 5 (detailed)
    let sortRune = null;
    let sortDir = "desc";

    function setErr(msg) {
      const box = el("loadErr");
      if (!msg) { box.style.display = "none"; box.textContent = ""; return; }
      box.style.display = "block";
      box.textContent = msg;
    }

    function buildRuneRows() {
      // If not showing all: always show the high-rune rows, regardless of pricing.
      if (!showAll) return [...HIGH_RUNE_ROWS];

      // Show-all: union all rune keys observed in boss drop datasets.
      const seen = new Set();
      for (const b of (bossesData || [])) {
        const d = b?.data?.drops || {};
        for (const k of Object.keys(d)) {
          const rk = normRune(k);
          if (!rk || EXCLUDE.has(rk)) continue;
          // keep only rune-looking keys (letters only)
          if (!/^[A-Z]+$/.test(rk)) continue;
          seen.add(rk);
        }
      }
      let list = Array.from(seen);
      const preferred = PREFERRED_ORDER.filter(r => list.includes(r));
      const extra = list.filter(r => !PREFERRED_ORDER.includes(r)).sort();
      return [...preferred, ...extra];
    }

    function currentBossColumns() {
      // Council (5) is a pack (5 kills) and not comparable to single-boss columns, so we omit it here.
      return BOSSES.filter(b => b.id !== "council5");
    }

    function buildBossOrder(runesMatrix, baseBosses) {
      const base = [...baseBosses];
      if (!sortRune) return base;

      const r = sortRune;
      base.sort((a, b) => {
        const av = runesMatrix?.[a.id]?.[r] || 0;
        const bv = runesMatrix?.[b.id]?.[r] || 0;
        const d = bv - av;
        return sortDir === "desc" ? d : -d;
      });
      return base;
    }

    function fmtScientific(p) {
      if (!(p > 0)) return "-";
      return Number(p).toExponential(precision);
    }

    function fmtOneIn(p) {
      if (!(p > 0)) return "-";
      const n = 1 / Number(p);
      if (!Number.isFinite(n)) return "-";
      return `1:${Math.round(n).toLocaleString("en-US")}`;
    }

    function fmtPerScale(p, scale, label) {
      if (!(p > 0)) return "-";
      const v = Number(p) * scale;
      // Use fixed decimals for intuitive reading; trim trailing zeros for compactness.
      const s = v.toFixed(precision).replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
      return s;
    }

    function cellText(p) {
      if (fmtMode === "onein") return fmtOneIn(p);
      if (fmtMode === "per10k") return fmtPerScale(p, 10000);
      if (fmtMode === "per1m") return fmtPerScale(p, 1000000);
      return fmtScientific(p);
    }

    function cellTitle(p) {
      if (!(p > 0)) return "0";
      const oneIn = 1 / p;
      const oneInStr = Number.isFinite(oneIn) ? `1:${Math.round(oneIn).toLocaleString("en-US")}` : "-";
      const per10k = (p * 10000).toFixed(3);
      const per1m = (p * 1000000).toFixed(3);
      return `perKill=${p} | ${oneInStr} | per10k=${per10k} | per1m=${per1m}`;
    }

    function buildMetaPills() {
      const first = bossesData?.[0]?.data;
      const meta = formatBossMeta(first);
      const bossCount = (bossesData || []).length;
      const modeLabel = (
        fmtMode === "onein" ? "1:N" :
        fmtMode === "per10k" ? "per 10k" :
        fmtMode === "per1m" ? "per 1M" :
        "scientific"
      );
      const pills = [
        `<span class="pill">dataset <strong>${meta || "-"}</strong></span>`,
        `<span class="pill">bosses <strong>${bossCount}</strong></span>`,
        `<span class="pill">mode <strong>${modeLabel}</strong></span>`,
        `<span class="pill">precision <strong>${precision}</strong></span>`,
      ];
      if (sortRune) pills.push(`<span class="pill">sorted <strong>${sortRune} ${sortDir === "desc" ? "down" : "up"}</strong></span>`);
      el("metaPills").innerHTML = pills.join("");
    }

    function render() {
      setErr(null);

      const runes = buildRuneRows();

      // matrix[bossId][rune] = perKill
      const matrix = {};
      for (const b of bossesData) {
        const d = b?.data?.drops || {};
        const m = {};
        for (const r of runes) m[r] = Number(d[r] || d[normRune(r)] || 0);
        matrix[b.id] = m;
      }

      const bossOrder = buildBossOrder(matrix, currentBossColumns());

      // head
      const thead = el("thead");
      thead.innerHTML = "";
      const hr = document.createElement("tr");
      hr.innerHTML = `<th class="corner">Rune</th>` + bossOrder.map(b => `<th class="mono">${b.label}</th>`).join("");
      thead.appendChild(hr);

      // body
      const tbody = el("tbody");
      tbody.innerHTML = "";

      for (const r of runes) {
        const tr = document.createElement("tr");

        const isSorted = sortRune === r;
        const arrow = isSorted ? (sortDir === "desc" ? "v" : "^") : "";

        const td0 = document.createElement("td");
        td0.className = "sticky runeBtn mono";
        td0.innerHTML = `${r} <span class="hint">${arrow}</span>`;
        td0.title = "Click to sort bosses by this rune";
        td0.onclick = () => {
          if (sortRune === r) {
            sortDir = (sortDir === "desc") ? "asc" : "desc";
          } else {
            sortRune = r;
            sortDir = "desc";
          }
          buildMetaPills();
          render();
        };
        tr.appendChild(td0);

        for (const b of bossOrder) {
          const p = matrix?.[b.id]?.[r] || 0;
          const td = document.createElement("td");
          td.className = "num";
          td.textContent = cellText(p);
          td.title = cellTitle(p);
          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      }

      buildMetaPills();
    }

    async function loadBossesData() {
      const cols = currentBossColumns();
      const rows = await Promise.all(
        cols.map(async (b) => {
          const data = await loadBossDropsByFileId(b.id);
          return { ...b, data };
        })
      );
      return rows;
    }

    async function main() {
      try {
        priceTable = await loadPriceTable();
        bossesData = await loadBossesData();

        // wire controls
        el("showAll").checked = showAll;
        el("showAll").onchange = (e) => { showAll = !!e.target.checked; sortRune = null; buildMetaPills(); render(); };

        el("fmtSel").value = fmtMode;
        el("fmtSel").onchange = (e) => { fmtMode = e.target.value; buildMetaPills(); render(); };

        el("precSel").value = String(precision);
        el("precSel").onchange = (e) => {
          const v = Number(e.target.value);
          precision = Number.isFinite(v) ? v : 3;
          buildMetaPills();
          render();
        };

        render();
      } catch (err) {
        setErr(String(err?.message || err));
      }
    }

    main();
  </script>
</body>
</html>
